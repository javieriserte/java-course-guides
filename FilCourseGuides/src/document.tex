%% Based on a TeXnicCenter-Templat%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%------------------------------------------------------------
%
\documentclass[a4paper, twoside]{article}%
%Options -- Point size:  10pt (default), 11pt, 12pt
%        -- Paper size:  letterpaper (default), a4paper, a5paper, b5paper
%                        legalpaper, executivepaper
%        -- Orientation  (portrait is the default)
%                        landscape
%        -- Print size:  oneside (default), twoside
%        -- Quality      final(default), draft
%        -- Title page   notitlepage, titlepage(default)
%        -- Columns      onecolumn(default), twocolumn
%        -- Equation numbering (equation numbers on the right is the default)
%                        leqno
%        -- Displayed equations (centered is the default)
%                        fleqn (equations start at the same distance from the right side)
%        -- Open bibliography style (closed is the default)
%                        openbib
% For instance the command \ documentclass[a4paper,12pt,leqno]{article}
% ensures that the paper size is a4, the fonts are typeset at the size 12p
% and the equation numbers are on the left side
%

% Lista de Paquetes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pifont}             % Maneja Fuentes 
%\usepackage{PTSans}            % Maneja Fuentes Sans Serif
%\usepackage{skak}               % simbolos de ajedrez
\usepackage[T1]{fontenc}        % Texto de alta calidad en pdfs
\usepackage{ae,aecompl}         % Texto de alta calidad en pdfs
\usepackage{pslatex}            % Texto de alta calidad en pdfs
\usepackage{textcomp}           % Cosas de Texto
\usepackage{multicol}           % Para manejar multiples columnas
\usepackage[ansinew]{inputenc}  % Para poner acentos
\usepackage[spanish]{babel}     % Para separar palabras al fin de los renglones.
\usepackage{amsmath}            % Para hacer matemÃ¡tica
\usepackage{amsfonts}           % Para hacer matemÃ¡tica
\usepackage{amssymb}            % Para hacer matemÃ¡tica
\usepackage{enumerate}          % Para Manehar Enumeraciones
\usepackage{vwcol}							% para manejar multiples columas
\usepackage{graphicx}						% Para manejar los grÃ¡ficos
\usepackage{fancyhdr}						% Para manejar encabezados y pie de pÃ¡ginas
\usepackage{lastpage}						% Crea una referencia a la Ãºltima pÃ¡gina. Util para numerar pÃ¡ginas de la forma "pÃ¡gina x de y"
%\usepackage{pageslts}						% Crea una referencia a la Ãºltima pÃ¡gina. Util para numerar pÃ¡ginas de la forma "pÃ¡gina x de y"

\usepackage{listings}
%\usepackage[final]{ps4pdf} 	  % para incluir archivos eps dentro del documento pdf
\usepackage{array}
\usepackage{soul}
\usepackage{boolexpr}

% ConfiguraciÃ³n de pÃ¡gina
%%%%%%%%%%%%%%%%%%%%%%%%%
\textwidth 14cm									% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\textheight 22.7cm							% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\oddsidemargin 1cm			  			% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\evensidemargin 1cm		  			% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\topmargin -0.5cm								% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\headheight 0cm									% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\headsep 10pt										% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\marginparwidth 0cm

% BibliografÃ­a
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}       % estilo de la bibliografia
	
% Titulo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\s}{\the\textwidth}	
\newcommand{\materiaName}{Curso OOP y Java}				                                                % Guardo el nombre de la asignatura.
\newcommand{\seminarioName}{Guía de ejercicios}    % Guardo el nombre de la guÃ­a de ejercicios.
\newcommand{\fecha}{9 y 10 de Diciembre de 2014}                                          % Guardo la fecha.
\newcommand{\titulo}{																										       	% Para hacer el TÃ­tulo como me gusta
	\begin{center}																												        % Para hacer el TÃ­tulo como me gusta
	\vspace*{-22pt}\large\textbf{\materiaName}\\										              % Para hacer el TÃ­tulo como me gusta				
	\vspace{2pt}\normalsize{\seminarioName}\\																% Para hacer el TÃ­tulo como me gusta
	\vspace{2pt}\small{\textbf{F}undación \textbf{I}nstituto \textbf{L}eloir}\\																									% Para hacer el TÃ­tulo como me gusta
	\vspace{-6pt}\rule{\textwidth}{0.4pt}
	\end{center}																													  % Para hacer el TÃ­tulo como me gusta
}

% Encabezado y Pie de PÃ¡gina
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\headheight=14pt																													% Creo el encabezado y pie pÃ¡gina que quiero.
\renewcommand{\headrulewidth}{0.4pt}																			% Creo el encabezado y pie pÃ¡gina que quiero.
\renewcommand{\footrulewidth}{0.4pt}																		% Creo el encabezado y pie pÃ¡gina que quiero.
\pagestyle{fancy}%																										% Creo el encabezado y pie pÃ¡gina que quiero.
\fancyfoot{}																															% Creo el encabezado y pie pÃ¡gina que quiero.
\lfoot{\footnotesize{Página \thepage\ de \pageref{LastPage}}}						% Creo el encabezado y pie pÃ¡gina que quiero.
\lhead{\footnotesize{\materiaName}}																				% Creo el encabezado y pie pÃ¡gina que quiero.
\rhead{\footnotesize{\fecha\  - \seminarioName}}												% Creo el encabezado y pie pÃ¡gina que quiero.

% Fuentes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\renewcommand{\familydefault}{\sfdefault}                                 % Cambia todas las fuentes a sans Serif

% Enumeraciones
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumi}{\textbf{\theenumi}}
\renewcommand{\theenumii}{\arabic{enumii}}
\renewcommand{\labelenumii}{\theenumii}

\begin{document}
  \titulo
\section{Ejercicio 1 - Clases para representar DNA y RNA}
En este ejercicio se van a crear Clases que nos permitan trabajar con secuencias 
de DNA y RNA. Para ello, haremos un primer diseño e implementación de nuestro 
modelo y luego haremos modificaciones sobre él para incluir abstracciones y 
mecanismos de reutilización de código.

En todo momento, nos interesará contar con dos clases, que llamaremos RNA y DNA.
Ambas deberán permitir recuperar un String con la secuencia en si, recuperar la 
longitud de la secuencia y obtener una secuencia reversa complementaria como un
objeto DNA o RNA. Además, la clase DNA debe responder transcribirse y así 
obtener una objeto de la clase RNA con la secuencia correspondiente.
\subsection{Parte uno}
El primer diseño consistirá de solamente las clases DNA y RNA: 
\begin{itemize}
  \item Ambas tendrán una variable de tipo String para representar el estado 
  interno, que contendrá la secuencia en sí misma. Para simplificar,  asumiremos 
  que las secuencias no contienen degeneraciones ni carácteres extraños. Si se 
  permitirán \textit{gaps}.   
  \item Ambas tendrán estos métodos: 
  \begin{description}
    \item[Constructor] Crea una instancia de DNA o RNA y la inicializa con una
    secuencia (pasado como parámetro en un \textit{String}). 
    \item[getSequence()] Devuelve un String con la secuencia. 
    \item[length()] Devuelve int int con la longitud de la secuencia.
    \item[getCompSeq()] Devuelve un objeto que representa la secuencia 
    reversa-complementaria. La clase del objeto que se devuelve es la misma que 
    la clase del objeto que llama al método (DNA para DNA, RNA para RNA). 
    Hay muchas formas de implementar este método, para este ejercicio 
    recomiendo:
    \begin{enumerate}
      \item Crear un \textit{Array} de \textit{char} del mismo tamaño de la 
      secuencia.
      \item Recorrer la secuencia original desde el fin hasta el principio, con 
      un \textit{for(;;)\{\ldots\}}.
      \item En cada iteración del recorrido tomar el caracter de la posición 
      actual y elegir con un \textit{switch} el caracter que representa a la
      base complementaria.
      \item Agregar el caracter complementario al \textit{Array} creado en el 
      inicio, yendo desde el comienzo hasta el fin. 
  \end{enumerate}
      Debajo se muestra el código base para este método.
  \end{description}
  \item La clase DNA tendrá el método:
  \begin{description}
  \item[transcribe()] Que devuelve un objeto de la clase RNA con la secuencia
  que le corresponde (puede implementarse muy fácilmente usando el método 
  \textit{replace(char buscado, char reemplazo)} de la clase \textit{String}.
\end{description} 
\end{itemize}

\subsection{Parte dos}
Este diseño puede mejorarse. El código de los métodos \textit{getSequence() y 
length()} son idénticos en ambos casos. También la forma de representar el 
estado interno del objeto es la misma. Es decir tenemos código duplicado. Para 
evitar esto vamos a crear una clase abstracta que sea superclase de RNA y DNA. 
Esta nueva clase contendrá el estado interno, y los métodos que mencionamos, y 
las clases RNA y DNA los heredarán. Es conveniente que el nombre de la nueva 
clase represente un concepto que sea una abstracción de DNA y RNA (ya no como 
clases en nuestro código, sino desde la bioquímica). Teniendo en cuenta que 
tanto el DNA, como el RNA \emph{son} ácidos nucleicos, un nombre adecuado para 
la nueva clase puede ser NucleicAcid.

\subsection{Parte tres}
El código de los métodos \textit{getCompSeq()} es casí idéntico.
Lo que se hará a continuación es escribir en la clase NucleicAcid un código que 
abstraiga las partes comunes del código de estos dos métodos, y que deje la 
responsabilidad de llevar a cabo partes partes diferentes a cada clase concreta.  
Para ello, se creará en NucAcid el método \textit{getComplementarySequence()}, 
que devolverá un \textit{String}. Se copiará el contenido del método  
\textit{getCompSeq()} de RNA o DNA. Este método devolveré un \textit{String} que
contendrá la secuencia complementaria. Este será el único método que compute la
creación de una secuencia comeplementaria. Ahora, el comportamiento de los 
métodos \textit{getCompSeq()} en RNA y DNA se verá muy reducido, solamente 
deberán:
\begin{enumerate}
  \item Llamar al método \textit{getComplementarySequence()} para obtener el 
  \textit{String} con la secuencia complementaria.
  \item Crear un nuevo objeto de retorno del tipo que corresponda (DNA o RNA) y 
  que contenga la secuencia complementaria.
  \item Devolver el resultado. 
\end{enumerate}

Se deben realizar modificaciones en el código que se tiene en este momento en
el método \textit{getComplementarySequence()}. Los cambios que hay son tres:
\begin{enumerate}
  \item El tipo del objeto que se devuelve.
  \item El código que elige la base complementaria de Uracilo (en RNA) y 
  Timina (en DNA).
  \item El código que elige la base complementaria de Adenina (en ambas clases).
\end{enumerate}
Las modificaciones necesarias para resolver los dos primeros puntos es trivial.
Para el tercer punto, se delegará la responsabilidad de saber que base le 
corresponde a la Adenina en las clases DNA y RNA. Para ello:
\begin{enumerate}
  \item Se creará el método abstracto \textit{getCompCharForAdenine()} en la 
  clase NucleicAcid.
  \item Al ser un método abstracto, se requiere que todas las subclases 
  concretas de NucleicAcid lo implementen. Entonces, se creará también este 
  método en DNA y RNA. En DNA deberá devolver 'T' y en RNA deberá devolver 'R'.
  \item Se modificará el código de \textit{getComplementarySequence()} para que
  utilice estos métodos. 
\end{enumerate}

\subsection{Parte cuatro}
En la última parte de este ejercicio se modificará el alcance de visión de los 
métodos de las tres clases. Los constructores y los métodos \textit{getCompSeq()},
\textit{getSequence()}, \textit{length()} y \textit{transcribe()} deben ser 
públicos (\textit{public}) y los demás métodos protejidos (\textit{protected}).

\subsection{Código para el método \textit{getCompSeq}}       
\lstset{language=Java,basicstyle=\small}
\begin{lstlisting}
  DNA getCompSeq() {
    int length = this.length();
      char[] newSeq = new char[length];
      for (int i=length; i>0;i--) {
        char currentChar = this.getSequence().charAt(i-1);
        switch (currentChar) {
          case 'a': case 'A': newSeq[length-i] = 'T'; break;
          case 'c': case 'C': newSeq[length-i] = 'G'; break;
          case 't': case 'T': newSeq[length-i] = 'A'; break;
          case 'g': case 'G': newSeq[length-i] = 'C'; break;
          case '-': newSeq[length-i] = '-'; break;
          default: newSeq[length-i] = 'N'; break;
        }
      }
      return new DNA(String.valueOf(newSeq));
   }
\end{lstlisting}

\subsection{Conceptos relacionados con el ejercicio}
\begin{itemize}
  \item Herencia.
  \item Clases abstractas y concretas.
  \item Métodos abstractos.
  \item Patrón de diseño: template method.
  \item Manejo de \textit{Strings}.
\end{itemize}

\section{Ejercicio 2 - Estructuras de datos}
En este ejercicio se va a trabajar con algunas de las estructuras de datos más comunes
presentes en la libreria de Java:
\begin{description}
	\item[Listas(List)]   Colección de datos ordenados y posiblemente repetidos.
	\item[Mapas(Map)]     Asociaciones del tipo Clave $\rightarrow$ Valor.
	\item[Conjuntos(Set)] Colección de datos sin orden y sin repeticiones. Es un representación
	                      del la noción matemática de conjunto.
\end{description}
Entre paréntesis se muestra la interfaz que le corresponde a cada una de ellas.
Para llevar adelante este ejercicio se necesitará usar variables de tipo genéricos (o \textit{Generics}).
Es esta ejercicio se crearán tres clases ejecutables. En una de ellas se trabajará con listas, en otra con mapas y en la última con conjuntos.

Las clases ejecutables en Java se diferencian del resto de las clases en que poseen un método de clase 
especial llamado \textit{main}. Dentro de este método escribiremos el código que querramos que se ejecute.
La declaración del método \textit{main} es:
\begin{lstlisting}
  public static void main(String[] args) {
  // hacer cosas.....
  // por ejemplo:
  // System.out.println("Este es una clase ejecutable");
  }
\end{lstlisting}
El método es \textit{public} indicando que puede llamarse fuera de la clase. Es \textit{static} indicando que
es un método de clase (y no de instancia). El tipo de retorno es \textit{void}, esto significa que el método no devuelve ningún valor. El método recibe como parámetro un \textit{Array} de \textit{String}. Estos son los parámetros con los se llama al programa. Por ejemplo, si se ejecuta en un terminal de línea de comandos:
\begin{verbatim}
>java -jar MiClaseEjecutable.jar con estos parámetros.
\end{verbatim}
Las palabras 'con', 'estos' y 'parámetros' serán en contenido del \textit{Array} \textit{args}.

\subsection{Parte 1}
La primera clase que se creará se llamará ListExample. Como se ha dicho antes, en Java las listas debe 
utilizar la interfaz \textit{List}. La interfaz \textit{List} nos dice con que mensajes las listas se van a
comunicar con el resto de las clases, pero carece de implementación y de estado interno. Entonces, deberemos
trabajar con alguna clase concreta que implemente la interfaz \textit{List}. Dentro de las colecciones que
ofrece Java, hay varias que lo hacen. Las más frecuentemente usadas son:
\begin{enumerate}
	\item ArrayList
	\item Vector
	\item LinkedList
\end{enumerate}
Cada una de ellas está implementada de forma diferente, las dos primeras usan Arrays para guardar los datos, pero la primera no es segura en un contexto concurrente y la segunda si lo es (a expensas de tiempo de cómputo). La tercera usa listas enlazadas en lugar de Arrays. Es decir, cada una de ellas almacena y manipula los datos de forma diferente. Sin embargo, como todas implementan la misma interfaz, es posible trabajar con ellas de la misma forma y pueden ser intercambiables si es necesario.

Los métodos más usados de la interfaz List son:
\begin{description}
	\item[add] Agregar un nuevo elemento.
	\item[addAll] Agrega todos los elementos de otra colección a la lista.
	\item[set] Reemplaza un elemento por otro.
  \item[get] Recupera un elemento por el índice (número de orden en la lista).
  \item[contains] Busca si un valor se encuentra en la lista.
  \item[remove] Elimina un elemento por el índice.
  \item[size] Devuelve la cantidad de elementos en la lista.
  \item[clear] Elimina todos los elementos de lista.
\end{description}

Las listas, como todas las colecciones, son objetos que almacenan otros objetos.
Una lista que almacena números enteros y una lista que almacena palabras no son intercambiables.
Por ello, el tipo ambas es diferente. Para describir estas dos listas se utiliza el operador \textit{<>} (\textit{diamod}).
\begin{lstlisting}
  // Lista de números enteros:
  List<Integer> listaDeEnteros = new ArrayList<>();
  // Lista de palabas:
  List<String> listaDeEnteros = new ArrayList<>();
\end{lstlisting}

Se agregarán a cada una de las tres listas 5000 de números generados al azar entre 1 y un millón. 
Luego, se compararán las listas de a pares y se contará la cantidad de elementos compartidos.

Se crearán los siguientes métodos de clase:
\begin{description}
	\item[fillListWithRandonNumbers] Este método debe recibir tres parámetros: una lista vacia, la cantidad de elementos a agregar a la lista y el valor máximo posible (el rango de valores será entre 1 y este valor). El método debe devolver la lista dada inicialmente con los valores agregados. (usar \textit{Math.Random()} para generar los números al azar.) 
	\item[compareTwoLists] Este método recibe dos listas de números y devuelve la cantidad de elementos en común que tienen (usar el método \textit{contains}). 
	\item[compareAllLists] Este método recibe una lista de listas de números y compara todos los pares posibles usando el método \textit{compareTwoLists}. El método no devuelve ningún valor, sino que imprime por pantalla los recuentos.
\end{description}

\subsection{Parte 2}
La segunda clase que se creará será SetExample. Los conjuntos (Sets) son 
agrupaciones de elementos del mismo tipo, sin orden y sin repetición.  
\textit{Set} es la interfaz, para usar uno, se debe elegir una clase concreta
que implementa la interfaz \textit{Set}. Las más comunes son:
\begin{description}
  \item[HashSet] Almacena los datos en una tabla de \textit{Hashing}.
  \item[TreeSet] Almacena los datos en una estructura de árbol.
\end{description}
Para declarar el tipo de un \textit{Set} es necesario usar el operador 
\textit{diamond}.
 \begin{lstlisting}
  // Lista de números enteros:
  Set<Integer> conjuntoDeEnteros = new TreeSet<>();
  // Lista de palabas:
  Set<String> conjuntoDePalabras = new HashSet<>();
\end{lstlisting}

\begin{description}
  \item[add] Agrega un nuevo elemento.
  \item[clear] Elimina todos los elementos.
  \item[contains] Busca en el conjunto si existe un elemento dada.
  \item[isEmpty] Pregunta si el conjunto está vacio.
\end{description}
Debido a que los conjuntos no tienen orden, no tiene sentido recorrer los
elementos por su índice o recuperar un elemento por su índice (¿Cuál es el 
primer elemento de un conjunto?).

En este ejemplo, se crearán dos \textit{Set}, uno de ellos será un 
\textit{HashSet} y el otro será un \textit{TreeSet}. Cada uno de ellos se 
llenará con un millón de números enteros al azar entre 1 y un millón. Se 
medirá el tiempo que se tarda en agregar todos los números a ambos conjuntos
(para esto usar el método System.nanoTime()). Luego se comparará la cantidad de 
elementos en común en ambos conjuntos. Esto se hará dos veces, en la primera se
recorren los elementos del \text{HashSet} y se pregunta al \textit{TreeSet} si 
contiene a ese elemento y en la segunda se recorren los elementos del 
\textit{TreeSet} y se pregunta al \text{HashSet} si contiene a ese elemento.

Para ello, se creará una clase ejecutable y los siguiente métodos de clase:
\begin{description}
  \item[fillSetWithRandomNumbers] Este método recibe tres parámetros: un 
  conjunto vacio, la cantidad de elementos a agregar al conjunto y el valor 
  máximo posible (el rango de valores será entre 1 y este valor). El método debe
  devolver el conjunto dado inicialmente con los valores agregados. Este método
  además debe medir el tiempo antes de agregar un elemento y al finalizar. 
  Una vez hecho esto, se calcula la diferencia de tiempos y se muestra.
  \item[compareTwoSets] Este método recibe dos parámetros: cada uno de ellos es
  un \textit{Set} de números enteros. El método debe devolver la cantidad de
  elementos en común entre los dos conjuntos. Se recorren todos los elementos
  del primer conjunto y en cada paso se pregunta al segundo conjunto si contiene
  a ese número. Este método también debe medir el tiempo antes de comenzar a 
  comparar y al finalizar. Luego, se muestra la diferencia de tiempo.   
\end{description}

\subsection{Parte 3}
La tercer clase que se creará será MapExample. Los mapas son estructuras de 
datos asociativas del tipo Clave $\rightarrow$ Valor, como un diccionario. 
Map es, al igual que List, una interfaz. Las clases más usadas que implementan 
Map son:
\begin{description}
	\item[HashMap] Organiza los datos en una tabla de \textit{hashing}.
	\item[TreeMap] Organiza los datos en un árbol autobalanceante.
\end{description}

La clave y el valor no tienen porque se del mismo tipo. 
Se pueden tener un mapa de enteros a enteros o de enteros a String, o cualquier otro objeto.
La declaración de tipo de los mapas también requiere usar el operador \textit{diamond}, pero ahora requerirá dos tipos diferentes:
\begin{lstlisting}
  // Mapa de enteros a enteros:
  Map<Integer,Integer> mapaDeEnterosAEnteros = new HashMap<>();
  // Mapa de enteros a palabras:
  Map<Integer,String> mapaDeEnterosAEnteros = new HashMap<>();
\end{lstlisting}

Lós metodos más comunes de la interfaz \textit{Map} son:
\begin{description}
  \item[put] Agrega un nuevo par clave $\rightarrow$ valor o reemplaza uno 
  existente.
  \item[get] Recupera un valor a parte de la clave.
  \item[clear] Elimina todos los pares.
  \item[keySet] Devuelve un conjunto con todas claves.
  \item[containsKey] Busca en el mapa si existe una clave dada.
  \item[isEmpty] Pregunta si el mapa está vacio.
\end{description}

En este ejemplo, se crearán 1000000 números enteros al azar entre uno y 1000000, 
y se usará un \textit{Map} para almacenar la cantidad de veces que aparece cada 
uno. Se mostrará el número más frecuente. Esto se repetirá unas 100 veces. El
valor de la clave más frecuente en cada repetición se almacenará en otro mapa 
(también de enteros a enteros). De forma tal que saber que cantidad de veces 
cierto recuento fue el máximo. Finalmente, se mostrarán todos los pares 
clave $\rightarrow$ valor de este segundo mapa. Para ello, se crearán los 
métodos de clase:

\begin{description}
  \item[updateKeyCount] Este método recibe dos parámetros: un mapa de enteros a 
  enteros y un número entero. Se debe preguntar al mapa si el número entero dado 
  existe. Si no existe, se agrega un núevo par con el número generado como clave
  y el número uno como valor; si existe, se incrementa en uno el valor asociado 
  a ese número. Finalmente, se devuelve el mapa actualizado.
  \item[fillMapWithRandomNumbers] Este método recibe tres parámetros: un mapa de 
  enteros a enteros vacio, el número de elementos que hay que agregar al mapa y 
  el valor máximo para cualquier número. El método debe devolver el mapa lleno, 
  con los números generados como clave y el recuento como valor. Cuando se 
  genera un nuevo número al azar, 
  \item[getMostFrequentKey] Este método recibe un solo parámetro: un mapa de
  enteros a enteros y devuelve la clave más frecuente. A mapa recibido se le 
  pide el conjunto de claves y se lo recorre preguntando en cada paso si la 
  clave actual es la más frecuente de las claves vistas.

\end{description}

Al igual que antes, se creará una clase ejecutable para hacer funcionar el 
ejemplo. 

\section{Ejercicio 3 - Juego de Hanoi}
En este ejercicio se crearán clases que permitirán jugar al juego de las torres
de Hanoi. En este juego hay discos de diferentes diámetros y un tablero con tres
varillas (que cumplen el rol de torres). El juego se inicia con todos los 
discos colocados en una de las varillas uno encima del otro tal que el diámetro
de un discos debe ser menor al diametro del disco que se encuentra 
inmediatamente debajo, si es que hay uno. El objetivo consiste en mover todos 
los discos de una torre a otra, de tal forma que siempre se cumplan es reglas:
\begin{itemize}
  \item Se puede mover un solo disco a la vez.
  \item Los movimientos consisten en tomar un disco que se encuentra en la cima 
  de una de las torre y colocarlo en la cima de una de las otras dos torres. 
  \item No se puede colocar un disco sobre otro de menor tamaño.
\end{itemize}

El modelo consistirá de las clases:
\begin{description}
  \item[Ring] Esta clase modelará a cada uno de los discos. Su estado interno
  consistirá de una sola variable que representará el radio del disco.
  \item[BoardGame] Esta clase modelará el tablero de juego.
  \item[HanoiClient] Esta será la clase ejecutable que nos permitirá 
  interactuar con el juego.
\end{description}
Entre un el \textit{HanoiClient} y el \textit{BoardGame} se establecerá una 
comunicación. El \textit{HanoiClient} solo podrá ordenarle a \textit{BoardGame} 
que intente realizar un movimiento. Esto lo hará a través de la interfaz pública
de \textit{BoardGame} y este le responderá según si el movimiento es válido,
es inválido, o si es válido y además ganó el juego.
Las respuestas del \textit{BoardGame} se modelarán con la enumeración 
\textit{BoardResponse} que contendrá tres valores: 'ILLEGAL_MOVE', 'VALID_MOVE',
'YOU_WIN'. 
El tablero de juego tiene tres varillas, para modelar la posición que 
corresponde a cada varilla se creará la enumeración \textit{BoardStacks}. Esta 
tendrá tres valores: 'LEFT', 'MIDDLE', 'RIGHT'.

El estado interno de un \textit{BoardResponse} contendrá cinco variables.
Una de ellas representará la cantidad de discos total en el juego.
Tres se ellas representarán las varillas en la que se cololan los discos.
Una para la izquierda, otra para la del medio y otra para la derecha.
La una de las varilla se reprenterá con una lista de discos 
(\textit{List<Ring>}). El contenido de estas listas cambiará luego de cada 
movimiento. Finalmente, la última variable del estado interno representará 
la posición de la varilla en la que deben colocarse todos los discos para ganar
el juego.

\textit{BoardResponse} contendrá los siguientes métodos públicos de instancia:
\begin{description}
  \item[move] Es el método que permite realizar los movimientos. Recibe dos
  parámetros de tipo \textit{BoardStacks}, la posición desde la cual se toma el 
  disco y la posición en la que se debe sejar el disco. Devuelve un valor de la 
  enumeración \textit{BoardResponse}. Este método debera hacer lo siguiente:
  \begin{enumerate}
    \item Intentar tomar un disco de la varilla de posición inicial, si no es 
    posible (porque la varilla esta vacia) se deberá devolver una respuesta de
    movimiento ilegal y terminar.
    \item Intentar colocar el disco tomado en la la varilla de la posición 
    final. Si no es posible se deberá devolver una respuesta de
    movimiento ilegal y terminar.
    \item Verificar si se ganó el juego, y devolver una respuesa de juego ganado
    si es así y terminar.
    \item Devolver una respuesta de movimiento válido. 
  \end{enumerate}
  \item[toString] Todos los objetos poseen este método, ya que lo heredan de
  \textit{Object}. Se reescribirá para dar una representación en texto del 
  estado de tablero, mostrando cuantos discos hay en cada torre.
\end{description}
También tendrá dos métodos constructores. Uno de ellos sin ninún parámetro, el 
otro debe recibir cinco parámetros, cada uno de ellos se corresponde con una de 
las variables del estado interno del objeto. Los dos constructores serán 
privados, por lo que no pueden ser usados fuera de esta clase. Hacer esto,
aparentemente, impide que se puedan crear objetos de este tipo. Sin embargo, es
posible si se utiliza un método de clase para construir los objetos. 
Por ello, \textit{BoardResponse} contendrá un método de clase que además de 
permitir la creación de los objetos, permitirá validar que la creación sea
correcta:
 \begin{description}
  \item[createBoardGame] Recibirá dos parámetros de tipo \textit{BoardStacks}, 
  indicando la posición inicial de todos los discos y la posición final a la que
  debe llegarse y un parámetro que es un número entero indicando la cantidad de 
  discos en el tablero. Debe devolver un objeto \textit{BoardGame} correctamente
  creado. Este método debe:
  \begin{itemize}
    \item Verificar ue las posiciones de inicio y fin sean diferentes.
    \item Verificar que la cantidad de discos sea mayor a cero.
    \item Crear una lista de discos y agregarle los discos, respetando las 
    reglas del juego.
    \item Crear dos listas de discos vacias.
    \item Crear un objeto \textit{BoardGame} correctamente armado.
  \end{itemize}
\end{description}

La clase \texit{HanoiClient} Será ejecutable y actuará de mediador entre el 
usuario humano y el juego. Es una clase que está separada del resto de las 
clases del modelo del juego. Esto no es casual, es una decisión de diseño que 
permitiría alterar la interfaz que interactúa con el humano sin tener que 
modificar nada del comportamiento del juego. Es este caso, se usará una interfaz
de línea de texto para jugar, pero si se quisiera, se podría construir otra 
interfaz, por ejemplo gráfica y esto se podría hacer sin tener que modificar las
clases \textit{BoardGame},y \textit{Ring}, ni las enumeraciones.

Las personas interacturán con esta clase mediante comandos de texto. Los
comandos de texto que se aceptarán son tres: 
\begin{itemize}
  \item MOVE \textit{X} TO \textit{X}. Donde X y Y se reemplazan por \textit{L},
  \textit{M} y \textit{R}, para denotar izquierda, centro y derecha. Por ejemplo
  un comando válido sería:
  \begin{verbatim}
  MOVE R TO L
  \end{verbatim}
  \item END. Para finalizar el juego.
  \item RESTART. Para comenzar un juego nuevo.
\end{itemize}

  


\section{Ejercicio 4 - Representación de terrenos con precisión variable}
\section{Ejercicio 5 - Mapa de rangos}

\end{document}
