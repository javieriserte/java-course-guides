%% Based on a TeXnicCenter-Templat%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%------------------------------------------------------------
%
\documentclass[a4paper, twoside]{article}%
%Options -- Point size:  10pt (default), 11pt, 12pt
%        -- Paper size:  letterpaper (default), a4paper, a5paper, b5paper
%                        legalpaper, executivepaper
%        -- Orientation  (portrait is the default)
%                        landscape
%        -- Print size:  oneside (default), twoside
%        -- Quality      final(default), draft
%        -- Title page   notitlepage, titlepage(default)
%        -- Columns      onecolumn(default), twocolumn
%        -- Equation numbering (equation numbers on the right is the default)
%                        leqno
%        -- Displayed equations (centered is the default)
%                        fleqn (equations start at the same distance from the right side)
%        -- Open bibliography style (closed is the default)
%                        openbib
% For instance the command \ documentclass[a4paper,12pt,leqno]{article}
% ensures that the paper size is a4, the fonts are typeset at the size 12p
% and the equation numbers are on the left side
%

% Lista de Paquetes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{pifont}             % Maneja Fuentes 
%\usepackage{PTSans}            % Maneja Fuentes Sans Serif
%\usepackage{skak}               % simbolos de ajedrez
\usepackage[T1]{fontenc}        % Texto de alta calidad en pdfs
\usepackage{ae,aecompl}         % Texto de alta calidad en pdfs
\usepackage{pslatex}            % Texto de alta calidad en pdfs
\usepackage{textcomp}           % Cosas de Texto
\usepackage{multicol}           % Para manejar multiples columnas
\usepackage[ansinew]{inputenc}  % Para poner acentos
\usepackage[spanish]{babel}     % Para separar palabras al fin de los renglones.
\usepackage{amsmath}            % Para hacer matemÃ¡tica
\usepackage{amsfonts}           % Para hacer matemÃ¡tica
\usepackage{amssymb}            % Para hacer matemÃ¡tica
\usepackage{enumerate}          % Para Manehar Enumeraciones
\usepackage{vwcol}							% para manejar multiples columas
\usepackage{graphicx}						% Para manejar los grÃ¡ficos
\usepackage{fancyhdr}						% Para manejar encabezados y pie de pÃ¡ginas
\usepackage{lastpage}						% Crea una referencia a la Ãºltima pÃ¡gina. Util para numerar pÃ¡ginas de la forma "pÃ¡gina x de y"
%\usepackage{pageslts}						% Crea una referencia a la Ãºltima pÃ¡gina. Util para numerar pÃ¡ginas de la forma "pÃ¡gina x de y"

\usepackage{listings}
%\usepackage[final]{ps4pdf} 	  % para incluir archivos eps dentro del documento pdf
\usepackage{array}
\usepackage{soul}
\usepackage{boolexpr}

% ConfiguraciÃ³n de pÃ¡gina
%%%%%%%%%%%%%%%%%%%%%%%%%
\textwidth 14cm									% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\textheight 22.7cm							% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\oddsidemargin 1cm			  			% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\evensidemargin 1cm		  			% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\topmargin -0.5cm								% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\headheight 0cm									% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\headsep 10pt										% Declaraciones para cambiar el tamaÃ±o del Ã¡rea de texto para usar
\marginparwidth 0cm

% BibliografÃ­a
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}       % estilo de la bibliografia
	
% Titulo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\s}{\the\textwidth}	
\newcommand{\materiaName}{Curso OOP y Java}				                                                % Guardo el nombre de la asignatura.
\newcommand{\seminarioName}{Guía de ejercicios}    % Guardo el nombre de la guÃ­a de ejercicios.
\newcommand{\fecha}{9 y 10 de Diciembre de 2014}                                          % Guardo la fecha.
\newcommand{\titulo}{																										       	% Para hacer el TÃ­tulo como me gusta
	\begin{center}																												        % Para hacer el TÃ­tulo como me gusta
	\vspace*{-22pt}\large\textbf{\materiaName}\\										              % Para hacer el TÃ­tulo como me gusta				
	\vspace{2pt}\normalsize{\seminarioName}\\																% Para hacer el TÃ­tulo como me gusta
	\vspace{2pt}\small{\textbf{F}undación \textbf{I}nstituto \textbf{L}eloir}\\																									% Para hacer el TÃ­tulo como me gusta
	\vspace{-6pt}\rule{\textwidth}{0.4pt}
	\end{center}																													  % Para hacer el TÃ­tulo como me gusta
}

% Encabezado y Pie de PÃ¡gina
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\headheight=14pt																													% Creo el encabezado y pie pÃ¡gina que quiero.
\renewcommand{\headrulewidth}{0.4pt}																			% Creo el encabezado y pie pÃ¡gina que quiero.
\renewcommand{\footrulewidth}{0.4pt}																		% Creo el encabezado y pie pÃ¡gina que quiero.
\pagestyle{fancy}%																										% Creo el encabezado y pie pÃ¡gina que quiero.
\fancyfoot{}																															% Creo el encabezado y pie pÃ¡gina que quiero.
\lfoot{\footnotesize{Página \thepage\ de \pageref{LastPage}}}						% Creo el encabezado y pie pÃ¡gina que quiero.
\lhead{\footnotesize{\materiaName}}																				% Creo el encabezado y pie pÃ¡gina que quiero.
\rhead{\footnotesize{\fecha\  - \seminarioName}}												% Creo el encabezado y pie pÃ¡gina que quiero.

% Fuentes
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\renewcommand{\familydefault}{\sfdefault}                                 % Cambia todas las fuentes a sans Serif

% Enumeraciones
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\labelenumi}{\textbf{\theenumi}}
\renewcommand{\theenumii}{\arabic{enumii}}
\renewcommand{\labelenumii}{\theenumii}

\begin{document}
  \titulo
\section{Ejercicio 1 - Clases para representar DNA y RNA}
En este ejercicio se van a crear Clases que nos permitan trabajar con secuencias 
de DNA y RNA. Para ello, haremos un primer diseño e implementación de nuestro 
modelo y luego haremos modificaciones sobre él para incluir abstracciones y 
mecanismos de reutilización de código.

En todo momento, nos interesará contar con dos clases, que llamaremos RNA y DNA.
Ambas deberán permitir recuperar un String con la secuencia en si, recuperar la 
longitud de la secuencia y obtener una secuencia reversa complementaria como un
objeto DNA o RNA. Además, la clase DNA debe responder transcribirse y así 
obtener una objeto de la clase RNA con la secuencia correspondiente.
\subsection{Parte uno}
El primer diseño consistirá de solamente las clases DNA y RNA: 
\begin{itemize}
  \item Ambas tendrán una variable de tipo String para representar el estado 
  interno, que contendrá la secuencia en sí misma. Para simplificar,  asumiremos 
  que las secuencias no contienen degeneraciones ni carácteres extraños. Si se 
  permitirán \textit{gaps}.   
  \item Ambas tendrán estos métodos: 
  \begin{description}
    \item[Constructor] Crea una instancia de DNA o RNA y la inicializa con una
    secuencia (pasado como parámetro en un \textit{String}). 
    \item[getSequence()] Devuelve un String con la secuencia. 
    \item[length()] Devuelve int int con la longitud de la secuencia.
    \item[getCompSeq()] Devuelve un objeto que representa la secuencia 
    reversa-complementaria. La clase del objeto que se devuelve es la misma que 
    la clase del objeto que llama al método (DNA para DNA, RNA para RNA). 
    Hay muchas formas de implementar este método, para este ejercicio 
    recomiendo:
    \begin{enumerate}
      \item Crear un \textit{Array} de \textit{char} del mismo tamaño de la 
      secuencia.
      \item Recorrer la secuencia original desde el fin hasta el principio, con 
      un \textit{for(;;)\{\ldots\}}.
      \item En cada iteración del recorrido tomar el caracter de la posición 
      actual y elegir con un \textit{switch} el caracter que representa a la
      base complementaria.
      \item Agregar el caracter complementario al \textit{Array} creado en el 
      inicio, yendo desde el comienzo hasta el fin. 
  \end{enumerate}
      Debajo se muestra el código base para este método.
  \end{description}
  \item La clase DNA tendrá el método:
  \begin{description}
  \item[transcribe()] Que devuelve un objeto de la clase RNA con la secuencia
  que le corresponde (puede implementarse muy fácilmente usando el método 
  \textit{replace(char buscado, char reemplazo)} de la clase \textit{String}.
\end{description} 
\end{itemize}

\subsection{Parte dos}
Este diseño puede mejorarse. El código de los métodos \textit{getSequence() y 
length()} son idénticos en ambos casos. También la forma de representar el 
estado interno del objeto es la misma. Es decir tenemos código duplicado. Para 
evitar esto vamos a crear una clase abstracta que sea superclase de RNA y DNA. 
Esta nueva clase contendrá el estado interno, y los métodos que mencionamos, y 
las clases RNA y DNA los heredarán. Es conveniente que el nombre de la nueva 
clase represente un concepto que sea una abstracción de DNA y RNA (ya no como 
clases en nuestro código, sino desde la bioquímica). Teniendo en cuenta que 
tanto el DNA, como el RNA \emph{son} ácidos nucleicos, un nombre adecuado para 
la nueva clase puede ser NucleicAcid.

\subsection{Parte tres}
El código de los métodos \textit{getCompSeq()} es casí idéntico.
Lo que se hará a continuación es escribir en la clase NucleicAcid un código que 
abstraiga las partes comunes del código de estos dos métodos, y que deje la 
responsabilidad de llevar a cabo partes partes diferentes a cada clase concreta.  
Para ello, se creará en NucAcid el método \textit{getComplementarySequence()}, 
que devolverá un \textit{String}. Se copiará el contenido del método  
\textit{getCompSeq()} de RNA o DNA. Este método devolveré un \textit{String} que
contendrá la secuencia complementaria. Este será el único método que compute la
creación de una secuencia comeplementaria. Ahora, el comportamiento de los 
métodos \textit{getCompSeq()} en RNA y DNA se verá muy reducido, solamente 
deberán:
\begin{enumerate}
  \item Llamar al método \textit{getComplementarySequence()} para obtener el 
  \textit{String} con la secuencia complementaria.
  \item Crear un nuevo objeto de retorno del tipo que corresponda (DNA o RNA) y 
  que contenga la secuencia complementaria.
  \item Devolver el resultado. 
\end{enumerate}

Se deben realizar modificaciones en el código que se tiene en este momento en
el método \textit{getComplementarySequence()}. Los cambios que hay son tres:
\begin{enumerate}
  \item El tipo del objeto que se devuelve.
  \item El código que elige la base complementaria de Uracilo (en RNA) y 
  Timina (en DNA).
  \item El código que elige la base complementaria de Adenina (en ambas clases).
\end{enumerate}
Las modificaciones necesarias para resolver los dos primeros puntos es trivial.
Para el tercer punto, se delegará la responsabilidad de saber que base le 
corresponde a la Adenina en las clases DNA y RNA. Para ello:
\begin{enumerate}
  \item Se creará el método abstracto \textit{getCompCharForAdenine()} en la 
  clase NucleicAcid.
  \item Al ser un método abstracto, se requiere que todas las subclases 
  concretas de NucleicAcid lo implementen. Entonces, se creará también este 
  método en DNA y RNA. En DNA deberá devolver 'T' y en RNA deberá devolver 'R'.
  \item Se modificará el código de \textit{getComplementarySequence()} para que
  utilice estos métodos. 
\end{enumerate}

\subsection{Parte cuatro}
En la última parte de este ejercicio se modificará el alcance de visión de los 
métodos de las tres clases. Los constructores y los métodos \textit{getCompSeq()},
\textit{getSequence()}, \textit{length()} y \textit{transcribe()} deben ser 
públicos (\textit{public}) y los demás métodos protejidos (\textit{protected}).

\subsection{Código para el método \textit{getCompSeq}}       
\lstset{language=Java,basicstyle=\small}
\begin{lstlisting}
  DNA getCompSeq() {
    int length = this.length();
      char[] newSeq = new char[length];
      for (int i=length; i>0;i--) {
        char currentChar = this.getSequence().charAt(i-1);
        switch (currentChar) {
          case 'a': case 'A': newSeq[length-i] = 'T'; break;
          case 'c': case 'C': newSeq[length-i] = 'G'; break;
          case 't': case 'T': newSeq[length-i] = 'A'; break;
          case 'g': case 'G': newSeq[length-i] = 'C'; break;
          case '-': newSeq[length-i] = '-'; break;
          default: newSeq[length-i] = 'N'; break;
        }
      }
      return new DNA(String.valueOf(newSeq));
   }
\end{lstlisting}

\subsection{Conceptos relacionados con el ejercicio}
\begin{itemize}
  \item Herencia.
  \item Clases abstractas y concretas.
  \item Métodos abstractos.
  \item Patrón de diseño: template method.
  \item Manejo de \textit{Strings}.
\end{itemize}

\section{Ejercicio 2 - Estructuras de datos}
En este ejercicio se va a trabajar con algunas de las estructuras de datos más comunes
presentes en la libreria de Java:
\begin{description}
	\item[Listas(List)]   Colección de datos ordenados y posiblemente repetidos.
	\item[Mapas(Map)]     Asociaciones del tipo Clave $\rightarrow$ Valor.
	\item[Conjuntos(Set)] Colección de datos sin orden y sin repeticiones. Es un representación
	                      del la noción matemática de conjunto.
\end{description}
Entre paréntesis se muestra la interfaz que le corresponde a cada una de ellas.
Para llevar adelante este ejercicio se necesitará usar variables de tipo genéricos (o \textit{Generics}).
Es esta ejercicio se crearán tres clases ejecutables. En una de ellas se trabajará con listas, en otra con mapas y en la última con conjuntos.

Las clases ejecutables en Java se diferencian del resto de las clases en que poseen un método de clase 
especial llamado \textit{main}. Dentro de este método escribiremos el código que querramos que se ejecute.
La declaración del método \textit{main} es:
\begin{lstlisting}
  public static void main(String[] args) {
  // hacer cosas.....
  // por ejemplo:
  // System.out.println("Este es una clase ejecutable");
  }
\end{lstlisting}
El método es \textit{public} indicando que puede llamarse fuera de la clase. Es \textit{static} indicando que
es un método de clase (y no de instancia). El tipo de retorno es \textit{void}, esto significa que el método no devuelve ningún valor. El método recibe como parámetro un \textit{Array} de \textit{String}. Estos son los parámetros con los se llama al programa. Por ejemplo, si se ejecuta en un terminal de línea de comandos:
\begin{verbatim}
>java -jar MiClaseEjecutable.jar con estos parámetros.
\end{verbatim}
Las palabras 'con', 'estos' y 'parámetros' serán en contenido del \textit{Array} \textit{args}.

\subsection{Parte 1}
La primera clase que se creará se llamará ListExample. Como se ha dicho antes, en Java las listas debe 
utilizar la interfaz \textit{List}. La interfaz \textit{List} nos dice con que mensajes las listas se van a
comunicar con el resto de las clases, pero carece de implementación y de estado interno. Entonces, deberemos
trabajar con alguna clase concreta que implemente la interfaz \textit{List}. Dentro de las colecciones que
ofrece Java, hay varias que lo hacen. Las más frecuentemente usadas son:
\begin{enumerate}
	\item ArrayList
	\item Vector
	\item LinkedList
\end{enumerate}
Cada una de ellas está implementada de forma diferente, las dos primeras usan Arrays para guardar los datos, pero la primera no es segura en un contexto concurrente y la segunda si lo es (a expensas de tiempo de cómputo). La tercera usa listas enlazadas en lugar de Arrays. Es decir, cada una de ellas almacena y manipula los datos de forma diferente. Sin embargo, como todas implementan la misma interfaz, es posible trabajar con ellas de la misma forma y pueden ser intercambiables si es necesario.

Los métodos más usados de la interfaz List son:
\begin{description}
	\item[add] Agregar un nuevo elemento.
	\item[addAll] Agrega todos los elementos de otra colección a la lista.
	\item[set] Reemplaza un elemento por otro.
  \item[get] Recupera un elemento por el índice (número de orden en la lista).
  \item[contains] Busca si un valor se encuentra en la lista.
  \item[remove] Elimina un elemento por el índice.
  \item[size] Devuelve la cantidad de elementos en la lista.
  \item[clear] Elimina todos los elementos de lista.
\end{description}

Las listas, como todas las colecciones, son objetos que almacenan otros objetos.
Una lista que almacena números enteros y una lista que almacena palabras no son intercambiables.
Por ello, el tipo ambas es diferente. Para describir estas dos listas se utiliza el operador \textit{<>} (\textit{diamod}).
\begin{lstlisting}
  // Lista de números enteros:
  List<Integer> listaDeEnteros = new ArrayList<>();
  // Lista de palabas:
  List<String> listaDeEnteros = new ArrayList<>();
\end{lstlisting}

Se agregarán a cada una de las tres listas 5000 de números generados al azar entre 1 y un millón. 
Luego, se compararán las listas de a pares y se contará la cantidad de elementos compartidos.

Se crearán los siguientes métodos de clase:
\begin{description}
	\item[fillListWithRandonNumbers] Este método debe recibir tres parámetros: una lista vacia, la cantidad de elementos a agregar a la lista y el valor máximo posible (el rango de valores será entre 1 y este valor). El método debe devolver la lista dada inicialmente con los valores agregados. (usar \textit{Math.Random()} para generar los números al azar.) 
	\item[compareTwoLists] Este método recibe dos listas de números y devuelve la cantidad de elementos en común que tienen (usar el método \textit{contains}). 
	\item[compareAllLists] Este método recibe una lista de listas de números y compara todos los pares posibles usando el método \textit{compareTwoLists}. El método no devuelve ningún valor, sino que imprime por pantalla los recuentos.
\end{description}

\subsection{Parte 2}
La segunda clase que se creará será SetExample. Los conjuntos (Sets) son 
agrupaciones de elementos del mismo tipo, sin orden y sin repetición.  
\textit{Set} es la interfaz, para usar uno, se debe elegir una clase concreta
que implementa la interfaz \textit{Set}. Las más comunes son:
\begin{description}
  \item[HashSet] Almacena los datos en una tabla de \textit{Hashing}.
  \item[TreeSet] Almacena los datos en una estructura de árbol.
\end{description}
Para declarar el tipo de un \textit{Set} es necesario usar el operador 
\textit{diamond}.
 \begin{lstlisting}
  // Lista de números enteros:
  Set<Integer> conjuntoDeEnteros = new TreeSet<>();
  // Lista de palabas:
  Set<String> conjuntoDePalabras = new HashSet<>();
\end{lstlisting}

\begin{description}
  \item[add] Agrega un nuevo elemento.
  \item[clear] Elimina todos los elementos.
  \item[contains] Busca en el conjunto si existe un elemento dada.
  \item[isEmpty] Pregunta si el conjunto está vacio.
\end{description}
Debido a que los conjuntos no tienen orden, no tiene sentido recorrer los
elementos por su índice o recuperar un elemento por su índice (¿Cuál es el 
primer elemento de un conjunto?).

En este ejemplo, se crearán dos \textit{Set}, uno de ellos será un 
\textit{HashSet} y el otro será un \textit{TreeSet}. Cada uno de ellos se 
llenará con un millón de números enteros al azar entre 1 y un millón. Se 
medirá el tiempo que se tarda en agregar todos los números a ambos conjuntos
(para esto usar el método System.nanoTime()). Luego se comparará la cantidad de 
elementos en común en ambos conjuntos. Esto se hará dos veces, en la primera se
recorren los elementos del \text{HashSet} y se pregunta al \textit{TreeSet} si 
contiene a ese elemento y en la segunda se recorren los elementos del 
\textit{TreeSet} y se pregunta al \text{HashSet} si contiene a ese elemento.

Para ello, se creará una clase ejecutable y los siguiente métodos de clase:
\begin{description}
  \item[fillSetWithRandomNumbers] Este método recibe tres parámetros: un 
  conjunto vacio, la cantidad de elementos a agregar al conjunto y el valor 
  máximo posible (el rango de valores será entre 1 y este valor). El método debe
  devolver el conjunto dado inicialmente con los valores agregados. Este método
  además debe medir el tiempo antes de agregar un elemento y al finalizar. 
  Una vez hecho esto, se calcula la diferencia de tiempos y se muestra.
  \item[compareTwoSets] Este método recibe dos parámetros: cada uno de ellos es
  un \textit{Set} de números enteros. El método debe devolver la cantidad de
  elementos en común entre los dos conjuntos. Se recorren todos los elementos
  del primer conjunto y en cada paso se pregunta al segundo conjunto si contiene
  a ese número. Este método también debe medir el tiempo antes de comenzar a 
  comparar y al finalizar. Luego, se muestra la diferencia de tiempo.   
\end{description}

\subsection{Parte 3}
La tercer clase que se creará será MapExample. Los mapas son estructuras de 
datos asociativas del tipo Clave $\rightarrow$ Valor, como un diccionario. 
Map es, al igual que List, una interfaz. Las clases más usadas que implementan 
Map son:
\begin{description}
	\item[HashMap] Organiza los datos en una tabla de \textit{hashing}.
	\item[TreeMap] Organiza los datos en un árbol autobalanceante.
\end{description}

La clave y el valor no tienen porque se del mismo tipo. 
Se pueden tener un mapa de enteros a enteros o de enteros a String, o cualquier otro objeto.
La declaración de tipo de los mapas también requiere usar el operador \textit{diamond}, pero ahora requerirá dos tipos diferentes:
\begin{lstlisting}
  // Mapa de enteros a enteros:
  Map<Integer,Integer> mapaDeEnterosAEnteros = new HashMap<>();
  // Mapa de enteros a palabras:
  Map<Integer,String> mapaDeEnterosAEnteros = new HashMap<>();
\end{lstlisting}

Lós metodos más comunes de la interfaz \textit{Map} son:
\begin{description}
  \item[put] Agrega un nuevo par clave $\rightarrow$ valor o reemplaza uno 
  existente.
  \item[get] Recupera un valor a parte de la clave.
  \item[clear] Elimina todos los pares.
  \item[keySet] Devuelve un conjunto con todas claves.
  \item[containsKey] Busca en el mapa si existe una clave dada.
  \item[isEmpty] Pregunta si el mapa está vacio.
\end{description}

En este ejemplo, se crearán 1000000 números enteros al azar entre uno y 1000000, 
y se usará un \textit{Map} para almacenar la cantidad de veces que aparece cada 
uno. Se mostrará el número más frecuente. Esto se repetirá unas 100 veces. El
valor de la clave más frecuente en cada repetición se almacenará en otro mapa 
(también de enteros a enteros). De forma tal que saber que cantidad de veces 
cierto recuento fue el máximo. Finalmente, se mostrarán todos los pares 
clave $\rightarrow$ valor de este segundo mapa. Para ello, se crearán los 
métodos de clase:

\begin{description}
  \item[updateKeyCount] Este método recibe dos parámetros: un mapa de enteros a 
  enteros y un número entero. Se debe preguntar al mapa si el número entero dado 
  existe. Si no existe, se agrega un núevo par con el número generado como clave
  y el número uno como valor; si existe, se incrementa en uno el valor asociado 
  a ese número. Finalmente, se devuelve el mapa actualizado.
  \item[fillMapWithRandomNumbers] Este método recibe tres parámetros: un mapa de 
  enteros a enteros vacio, el número de elementos que hay que agregar al mapa y 
  el valor máximo para cualquier número. El método debe devolver el mapa lleno, 
  con los números generados como clave y el recuento como valor. Cuando se 
  genera un nuevo número al azar, 
  \item[getMostFrequentKey] Este método recibe un solo parámetro: un mapa de
  enteros a enteros y devuelve la clave más frecuente. A mapa recibido se le 
  pide el conjunto de claves y se lo recorre preguntando en cada paso si la 
  clave actual es la más frecuente de las claves vistas.

\end{description}

Al igual que antes, se creará una clase ejecutable para hacer funcionar el 
ejemplo. 

\section{Ejercicio 3 - Juego de Hanoi}
En este ejercicio se crearán clases que permitirán jugar al juego de las torres
de Hanoi. En este juego hay discos de diferentes diámetros y un tablero con tres
varillas (que cumplen el rol de torres). El juego se inicia con todos los 
discos colocados en una de las varillas uno encima del otro tal que el diámetro
de un discos debe ser menor al diametro del disco que se encuentra 
inmediatamente debajo, si es que hay uno. El objetivo consiste en mover todos 
los discos de una torre a otra, de tal forma que siempre se cumplan es reglas:
\begin{itemize}
  \item Se puede mover un solo disco a la vez.
  \item Los movimientos consisten en tomar un disco que se encuentra en la cima 
  de una de las torre y colocarlo en la cima de una de las otras dos torres. 
  \item No se puede colocar un disco sobre otro de menor tamaño.
\end{itemize}

El modelo consistirá de las clases:
\begin{description}
  \item[Ring] Esta clase modelará a cada uno de los discos. Su estado interno
  consistirá de una sola variable que representará el radio del disco.
  \item[BoardGame] Esta clase modelará el tablero de juego.
  \item[HanoiClient] Esta será la clase ejecutable que nos permitirá 
  interactuar con el juego.
\end{description}
Entre un el \textit{HanoiClient} y el \textit{BoardGame} se establecerá una 
comunicación. El \textit{HanoiClient} solo podrá ordenarle a \textit{BoardGame} 
que intente realizar un movimiento. Esto lo hará a través de la interfaz pública
de \textit{BoardGame} y este le responderá según si el movimiento es válido,
es inválido, o si es válido y además ganó el juego.
Las respuestas del \textit{BoardGame} se modelarán con la enumeración 
\textit{BoardResponse} que contendrá tres valores: 'ILLEGAL_MOVE', 'VALID_MOVE',
'YOU_WIN'. 
El tablero de juego tiene tres varillas, para modelar la posición que 
corresponde a cada varilla se creará la enumeración \textit{BoardStacks}. Esta 
tendrá tres valores: 'LEFT', 'MIDDLE', 'RIGHT'.

El estado interno de un \textit{BoardResponse} contendrá cinco variables.
Una de ellas representará la cantidad de discos total en el juego.
Tres se ellas representarán las varillas en la que se cololan los discos.
Una para la izquierda, otra para la del medio y otra para la derecha.
La una de las varilla se reprenterá con una lista de discos 
(\textit{List<Ring>}). El contenido de estas listas cambiará luego de cada 
movimiento. Finalmente, la última variable del estado interno representará 
la posición de la varilla en la que deben colocarse todos los discos para ganar
el juego.

\textit{BoardResponse} contendrá los siguientes métodos públicos de instancia:
\begin{description}
  \item[move] Es el método que permite realizar los movimientos. Recibe dos
  parámetros de tipo \textit{BoardStacks}, la posición desde la cual se toma el 
  disco y la posición en la que se debe sejar el disco. Devuelve un valor de la 
  enumeración \textit{BoardResponse}. Este método debera hacer lo siguiente:
  \begin{enumerate}
    \item Intentar tomar un disco de la varilla de posición inicial, si no es 
    posible (porque la varilla esta vacia) se deberá devolver una respuesta de
    movimiento ilegal y terminar.
    \item Intentar colocar el disco tomado en la la varilla de la posición 
    final. Si no es posible se deberá devolver una respuesta de
    movimiento ilegal y terminar.
    \item Verificar si se ganó el juego, y devolver una respuesa de juego ganado
    si es así y terminar.
    \item Devolver una respuesta de movimiento válido. 
  \end{enumerate}
  \item[toString] Todos los objetos poseen este método, ya que lo heredan de
  \textit{Object}. Se reescribirá para dar una representación en texto del 
  estado de tablero, mostrando cuantos discos hay en cada torre.
\end{description}
También tendrá dos métodos constructores. Uno de ellos sin ninún parámetro, el 
otro debe recibir cinco parámetros, cada uno de ellos se corresponde con una de 
las variables del estado interno del objeto. Los dos constructores serán 
privados, por lo que no pueden ser usados fuera de esta clase. Hacer esto,
aparentemente, impide que se puedan crear objetos de este tipo. Sin embargo, es
posible si se utiliza un método de clase para construir los objetos. 
Por ello, \textit{BoardResponse} contendrá un método de clase que además de 
permitir la creación de los objetos, permitirá validar que la creación sea
correcta:
 \begin{description}
  \item[createBoardGame] Recibirá dos parámetros de tipo \textit{BoardStacks}, 
  indicando la posición inicial de todos los discos y la posición final a la que
  debe llegarse y un parámetro que es un número entero indicando la cantidad de 
  discos en el tablero. Debe devolver un objeto \textit{BoardGame} correctamente
  creado. Este método debe:
  \begin{itemize}
    \item Verificar ue las posiciones de inicio y fin sean diferentes.
    \item Verificar que la cantidad de discos sea mayor a cero.
    \item Crear una lista de discos y agregarle los discos, respetando las 
    reglas del juego.
    \item Crear dos listas de discos vacias.
    \item Crear un objeto \textit{BoardGame} correctamente armado.
  \end{itemize}
\end{description}

La clase \texit{HanoiClient} Será ejecutable y actuará de mediador entre el 
usuario humano y el juego. Es una clase que está separada del resto de las 
clases del modelo del juego. Esto no es casual, es una decisión de diseño que 
permitiría alterar la interfaz que interactúa con el humano sin tener que 
modificar nada del comportamiento del juego. Es este caso, se usará una interfaz
de línea de texto para jugar, pero si se quisiera, se podría construir otra 
interfaz, por ejemplo gráfica y esto se podría hacer sin tener que modificar las
clases \textit{BoardGame},y \textit{Ring}, ni las enumeraciones.

Las personas interacturán con esta clase mediante comandos de texto. Los
comandos de texto que se aceptarán son tres: 
\begin{itemize}
  \item MOVE \textit{X} TO \textit{X}. Donde X y Y se reemplazan por \textit{L},
  \textit{M} y \textit{R}, para denotar izquierda, centro y derecha. Por ejemplo,
  un comando válido es:
  \begin{verbatim}
  MOVE R TO L
  \end{verbatim}
  \item END. Para finalizar el juego.
  \item RESTART. Para comenzar un juego nuevo, opcionalmente se le puede decir que cantidad de discos
  se quieren en el juego.
\end{itemize}
Para intepretar los comandos de texto se puede usarán la siguientes expresiones regulares:
\begin{description}
	\item[Move]    "\\s*MOVE\\s+(?<from>[LRM])\\s+TO\\s+(?<to>[LRM])\\s*"
	\item[END]     "\\s*END\\s*"
	\item[RESTART] "\\s*RESTART(\\s*(?<rings>[0-9]+))*"
\end{description}
El manejo de expresiones regulares en Java se hace mediante las clases \textit{Pattern} y \textit{Matcher}.

La ejecución del juego se hace por medio de un bucle condicional (la condición que se evalúa es si se desea 
terminar el juego) en el método \textit{main}. Dentro del bucle se llevan a cabo varias acciones en serie:
\begin{enumerate}
	\item Se crea el tablero para un juego nuevo si es necesario, y se muetra su estado inicial.
	\item Se lee una línea de texto del \textit{standard input} (la consola).
	\item Se evalúa si el texto ingresado corresponde con alguna de las expresiones regulares de los comandos.
	\item Si el texto corresponde con END, se termina la ejecución del programa.
	\item Si el texto corresponde con RESTART, se reinicia el bucle del juego, indicando que se cree un nuevo tablero.
	\item Si el texto corresponde con MOVE, se extraen los valores que corresponden a las posiciones de    inicio y fin de la expresión regular. Luego se llama al método \textit{move()} del tablero con usando los valores extraídos como parámetros.
	\item Evaluar la respuesta obtenida del método \textit{move()}. Ejecutar un acción acorde a la respuesta obtenida.
	\item Si el texto no corresponde con ninguna de las expresiones regulares, se muestra un mensaje que dice que no se puede reconocer el comando.
\end{enumerate}

\section{Ejercicio 4 - Mapa de rangos}
En este ejercicio se escribirán las clases para construir una mapa de rangos.
Al igual que los mapas comunes, los mapas de rango son asociaciones de tipo Clave $\rightarrow$ Valor, sin
embargo, la clave no es explícita. Sino que se define un rango de elementos como clave, los cuales están 
todos asociados al mismo valor. Por ejemplo, se puede asociar el rango $[0,10]$ al valor 'A', el rango 
$[11,20]$ el valor B, etc. Los mapas siempre devuelven un único valor para cada clave, por ello, está
implícito que los rangos no deben solaparse.

\subsection{Primer parte}
En la primer parte del ejercicio se escribirá una clase \textit{Range} especializada para almacenar rangos
de números de punto flontante de doble precisión (\textit{Double}). El estado interno de esta clase tendrá
dos variables que definirán el límite inferior y el límite superior del rango. 
Además, es necesario indicar si los límites son cerrados o abiertos. Es decir si el valor del límite 
pertenece al rango (cerrado) o no pertenece (abierto). Para ello, necesitaremos dos variables booleanas (una 
para cada límite).

El método constructor de esta clase recibirá los cuatro valores que definen el estado interno. También se 
deberá verificar que el límite inferior es menor o igual que el límite superior, si no lo es, se invertirá 
el orden de los valores. \textit{Range} tendrá tres métodos de instancia:
\begin{description}
	\item[constains] Verifica si una valor dada pertenece al rango. El método recibirá un solo parámetro, un 
	\textit{Double} y debe devolver verdadero si el valor pertenece al rango y falso en caso contrario.
	Debajo se muestra un código de ejemplo para la implementación de este método.
	\item[intersects] Verifica si este rango comparte al menos un valor con otro rango dado. El método recibirá
	un parámetro de tipo \texit{Range} y devolverá un verdadero si los rangos comparten al menos un valor o 
	falso en caso contrario.
	\item[toString] Redefinición del metodo heredado de \textit{Object} para representar el rango. Debe devolver un \textit{String} que contenga los dos valores, separados por una coma y encerrados con '(','[',')' o ']'. De acuerdo si el límite es cerrado ('[', ']') o abierto ('(', ')'). Por ejemplo:
	\begin{itemize}
	  \item [0,1] : Rango de todos los valores mayor o iguales a 0, y menores o iguales a 1.
	  \item [2,3) : Rango de todos los valores mayor o iguales a 2, y menores a 3.
  \end{itemize}
  \item[getters and setters] Métodos para acceder a las variables del estado interno.
\end{description}

\subsection{Segunda parte}
La clase \textit{Range} creada en el parte anterior funciona bien para \texit{Doubles}. 
Sin embargo, si se quisiera usar con números enteros o caracteres u otro objetos no sería posible.
Debería escribirse, ese esos casos, clases con comportamiento prácticamente idéntico, pero 
especializada para cada tipo de datos.

En esta parte, se introucirá el concepto de variables de tipo genérico para poder escribir un única clase 
\textit{Range} que sea capaz de utilizar a cualquier (o casi) tipo. Para hacer esto, se debe usar el operador
\textit{Diamond}. En ejercicios anteriores, se lo utilizó para poder trabajar con clases genéricas (por ejemplo \textit{List}). Ahora se utilizará con otro fin, para escribir una clase genérica.

La declaración de la clase \textit{Range} en la primer parte es:
\begin{lstlisting}
	public class Range {
	  private Double upperBound;
	  //... 
	  public boolean contains(Double key) { 
	  //...
	  }
	}
\end{lstlisting}
Ahora, la declaración de \textit{Range} podría ser:
\begin{lstlisting}
	public class Range<K> {
	  private K upperBound;
	  //... 
	  public boolean contains(K key) { 
	  //...
	  }
	}
\end{lstlisting}
Nótese, que la variable de tipo genérico \texit{K}, está reemplazando a Double en todos los lugares donde 
este aparecía. Con esta declaración \texit{K} podría ser cualquier tipo. Esto es beneficioso ya que permite
escribir programas de forma abstracta, pero impone una limitación, como se es posible saber el tipo exacto de
\texit{K}, todos los métodos específicos no estarán disponibles. Solo estarán disponibles los métodos 
heredados de \textit{Object} y los operadores que pueden utilizar un \textit{Object} (implicitamente K 
hereda de \textit{Object}). En este ejemplo, parece no ser 
importante esta limitación, porque no se está utilizando ningún método de \texit{Double} en la clase 
\textit{Range}. Sin embargo, se está haciendo uso de los operadores de comparación por mayor y menor ('>','<'), los cuales no están disponibles en \textit{Object} (no todos los objetos son comparables, aunque
tengan el mismo tipo). Esto se traduce en que los objetos del tipo genérico K debe ser comparables entre si.
Esto puede lograrse muy fácilmente en Java:
\begin{lstlisting}
  public class Range<K extends Comparable<K>> {
  // ... código
  }
\end{lstlisting}
Aquí se introducen dos ideas. Por un lado, \texit{Comparable<K>} es un interfaz para explicitar que un objeto es comparable con otro (en este caso, \textit{K}). Por otro lado, la palabra reservada \texit{extends} se usa para indicar que un tipo hereda de otro. Por ejemplo, \textit{A extends B}, significa que la clase A es subclase de B. En concreto, en la nueva declaración de \textit{Range} se está exigiendo
que los objetos de tipo \textit{K} sean comparables con otros objetos de tipo \textit{K}. Si se quisiera crear un rango de un tipo que no cumple esto, el programa no podrá compilarse y se obtendrá un mensaje de error. Será necesario además, cambiar algunas partes del código, en particular en los lugar donde se utilizan
los operadores de comparación. En su lugar, se deben usar los métodos que provee la interfaz \texit{Comparable<K>} (esencialmente, el método \textit{compareTo}).

\subsection{Tercera parte}
La clase \textit{Range} creada en la parte anterior se usará como base para la implementación de una clase 
\textit{RangeMap}. Esta clase, asociará un valor para cada cada rango. El tipo de los valores devueltos por
el mapa puede diferir al tipo del rango usado como clave. Por ello, la clase \textit{RangeMap} será genérica para el tipo de los rangos y para el tipo del los valores devueltos:
\begin{lstlisting}
  public class RangeMap<K extends Comparable<K>,V> {
  // ... código
  }
\end{lstlisting}
El tipo K corresponde a los rangos, y el tipo V, corresponde a los valores devueltos.

La implementación de esta clase será sencilla, se mandendrán en el estado interno de \textit{RangeMap} dos listas. Una para los rangos, otra para los valores. Las dos listas comienzan vacias y se van llenando a medida que se agregan datos al mapa. Siempre se agrega al misma tiempo un rango y un valor, por lo que el índice de los pares (rango, valor) asociado son los mismos en ambas listas.

El constructor de esta clase no recibirá parámetros, pero debe crear inicializar las listas del estado interno con listas vacias. Esta clase tendrá dos métodos de instancia:
\begin{description}
	\item[put] Recibe dos parámetros, un rango y un valor. No devuelve nada.
	\item[get] Recibe un parámetro de tipo \textit{K}, devuelve el valor (de tipo \textit{V}) que está
	 asociado al rango al cual pertenece el parámetro. Si no hay un rango al cual pertenezca el parámetro,
	 se devolverá \textit{null}.
\end{description}cr

\subsection{Parte Cuatro}
La clase \textit{Range} es una posible solución a al problema planteado.
Es posible crear otras clases lleven a caba la misma tarea que \textit{RangeMap} (en términos de 
asociar rangos a valores) pero con implmentaciones muy diferentes. Del mismo modo que existen diferentes implementaciones de listas y conjuntos.
Todas ellas, tendrán un método \textit{get} y otro \textit{put}, que harán lo mismo que su contraparte de
\textit{RangeMap}. A pesar de todas estas similitudes, estas clases no pueden ser intercambiadas y representadas en forma abstrata. Para remediar esto, se puede crear una \textit{interface} que reuna los métodos comunes a estas clases . 
La declaración de una \textit{interface} es muy similar a la de una clase:
\begin{lstlisting}
public interface RangeMap <K extends Comparable<K>,V> {
	public V put(Range<K> key, V value) ;
	public V get(K key) ;
}
\end{lstlisting}
Los métodos que se declaran en un \textit{interface} no contienen implementación. La implementación
de los métodos está a cargo de las clases particulares que implementan la interfaz.

La clase \textit{RangeMap} de la parte anterior se renombrará a \textit{ListRangeMap}.
Luego se creará la interfaz \textit{RangeMap}, declarando los métodos (\textit{get} y otro \textit{put}).
Finalmente, se modificará \textit{ListRangeMap}. Para ello, solo debe modificarse la declaración de la clase:
\begin{lstlisting}
public class ListRangeMap<K extends Comparable<K>,V> implements RangeMap<K , V> {
// El mísmo código...
}
\end{lstlisting}
La palabra clave \textit{implements} se usa para indicar que la clase implementa cierta interfaz.

\subsection{Código de ejemplo de los métodos \textit{contains} y \textit{intersects}}
\begin{lstlisting}
	public boolean contains(Double key) {
			
		Double upper = this.getUpperBound();
		Double lower = this.getLowerBound();
		
		boolean res = (((key < upper) || (key == upper && this.isUpperClosed())) && 
				           ((key > lower) || (key == upper && this.isLowerClosed())));
		return res;
	}

	public boolean intersects(Range otherRange) {
		
		Double lowerR1 = this.getLowerBound();
		Double upperR1 = this.getUpperBound();
		
		Double lowerR2 = otherRange.getLowerBound();
		Double upperR2 = otherRange.getUpperBound();
		
		boolean res = 
		          ( 
		            upperR2 > lowerR1 || 
		            (upperR2 == lowerR1 &&  otherRange.isUpperClosed() && this.isLowerClosed())
		          ) && ( 
		            upperR1 > lowerR2 || 
				        (upperR1 == lowerR2 &&  otherRange.isUpperClosed() && this.isLowerClosed())
				      );
				
		return res;
\end{lstlisting}
\subsection{Parte Cinco}
Teniendo declarada la \textit{interface} \textit{RangeMap}, se utilizará otra clase que la implemente.
Los archivos AvlRangeMap.java, AvlRangeMapNode.java y LowerBoundRangeComparator.java contienen las clases necesarias para una implementación alternativa de \textit{RangeMap}. Esta implementación es batante más compleja que la anterior. Está basada en un árbol binario de búsqueda que tiene la propiedad de balancear la cantidad de nodos en sus ramas. Esta estructura de datos se conoce como árbol AVL (AVL, es la abreviatura de los nombres de los autores). No es necesario modificar el código de esta clase, salvo posiblemente verificar el nombre del paquete y de las clases importadas (son las primeras líneas del código, comienzan con \textit{package} e \textit{import}).

Se escribirá una clase \textit{RangeMapExample} para evaluar las dos implementaciones de \textit{RangeMap}.

\section{Ejercicio 5 - Representación de mapas con precisión variable}

En este ejercicio se crearán clases para representar un mapa (geográfico) con precisión varibles.
El objetivo es construir una estructura de datos que pueda describir con mucha precisión regiones del
mapa con mucho detalle y con poca precisión regiones que no tengan tanto detalle.

Los mapas que se representarán son muy simples, serán siempre cuadrados y el terreno del mapa puede ser
tierra o agua. Es posible imaginar este mapa como una imagen cuadrada de dos colores.
En esta representación usaremos celdas unitarias. Las celdas unitarias son siempre cuadradas, pueden ser representar agua o tierra y el tamaño de la porción del terreno que representan es variable.

Se podría representar el mapa entero con una sola celda unitaria, sin embargo, esto implicaría perder casi todo el detalle del mapa. La estrategia que se utilizará será dividir el mapa en cuatro regiones: arriba a la derecha, arriba a la izquierda, abajo a la derecha y abajo a la izquierda. 
Cada una de estas cuatro regiones podría ser una celda unitaria, si la presición es suficiente o
puede dividirse nuevamente en cuatro. El proceso de división en cuatro puede continuar indefinidamente, dando cada vez más y más detalle.

Para modelar esta idea se escribirá la enumeración \textit{Terrain} que contiene tres valores:
\textit{WATER}, \textit{LAND}, \textit{MIXED}. Además, se escribirán tres clases: \textit{Region}, \textit{Block} y \textit{UnitCell}.

\textit{Region} es una clase abstracta. Las clases \textit{Block} y \textit{UnitCell} heredan de \textit{region}. \textit{Region} que contiene cuatro métodos abstractos:
\begin{description}
  \item[simplify] Intenta simplificar la estructura del mapa.
	\item[isBlock] Devuelve verdadero si el objeto es de la clase \textit{Block}.
	\item[countElements] Devuelve la cantidad de elementos que hay en la estructura.
	\item[getTarrain] Devuelve un valor que indica si todo el terreno representado por el objeto es agua, o tierra o una mezcla de ambos.
\end{description}

Las clases concretas \textit{Block} y \textit{UnitCell} deben implementar estos métodos.
La clase \textit{UnitCell} representa a las celdas unitarias. El estado interno solo tiene una variable para
representar el tipo terreno (agua o tierra).
La implementación de la clase \textit{UnitCell} es bastante sencilla:
\begin{description}
  \item[simplify] Se devuelve el objeto \textit{UnitCell}. No hay una estrucura más sencilla que una celda unitaria.
	\item[isBlock] Devuelve falso.
	\item[countElements] Una celda unitaria no contiene más elementos que ella misma, por lo tanto devuelve 1.
	\item[getTarrain] Devuelve agua o tierra. 
\end{description}

La clase \textit{Block} representa a las divisiones en cuatro de una región.
El estado interno tiene cuatro variables, una para cada subdivisión (arriba al derecha, arriba a la izquiera, etc). El tipo de estas variables es \textit{Region} (por lo tanto, cada subregión puede volver a subdividirse o no). La implementación de los métodos es más compleja:

\begin{description}
  \item[simplify] Si el tipo de terreno de las cuatro subpartes es el mismo, se devuelve una celda unitaria del tipo de terreno que corresponde. Si no, intenta simplificar cada una de las subregiones.
	\item[isBlock] Devuelve verdadero.
	\item[countElements] Cuenta los elementos de las cuatro subpartes, los suma, le agrega 1 y devuelve ese valor.
	\item[getTarrain] Pregunta a las cuatro subpartes el tipo de terreno. Si todas coinciden, devuelve el valor correspondiente (agua o tierra). De lo contrario, devuelve un valor que representa un tipo de terreno mezclado.
\end{description}


\end{document}